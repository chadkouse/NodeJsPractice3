{
  "name": "halacious",
  "version": "1.2.1",
  "description": "A better HAL processor for Hapi",
  "main": "index.js",
  "scripts": {
    "test": "mocha test"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/bleupen/halacious"
  },
  "keywords": [
    "HAL",
    "Hapi",
    "hypermedia",
    "HATEOAS"
  ],
  "author": {
    "name": "Brad Leupen"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/bleupen/halacious/issues"
  },
  "homepage": "https://github.com/bleupen/halacious",
  "devDependencies": {
    "hapi": "^3.1.0",
    "mocha": "^1.20.1",
    "chai": "^1.9.1",
    "sinon": "^1.10.2",
    "sinon-chai": "^2.5.0"
  },
  "dependencies": {
    "hoek": "^2.3.0",
    "joi": "^4.5.0",
    "lodash": "^2.4.1",
    "swig": "^1.3.2",
    "swig-extras": "0.0.1",
    "url-template": "^2.0.4",
    "async": "^0.9.0",
    "negotiator": "^0.4.5",
    "URIjs": "^1.13.2"
  },
  "readme": "#halacious\n\na better HAL processor for Hapi\n\n##Overview\n*Halacious* is a plugin for the HapiJS web application server that makes **HATEOASIFYING** your app ridiculously\neasy. When paired with a well-aged HAL client-side library, you will feel the warmth of loose API coupling and the feeling\nof moral superiorty as you rid your SPA of hard-coded api links. \n\nHalacious removes the boilerplate standing between between you and a Restful application, allowing you to focus on your app's\nsecret sauce. Halacious embraces Hapi's configuration-centric approach to application scaffolding. Most common tasks can \nbe accomplished without writing any code at all.\n \n##Features\n- Dead-simple namespace/rel registration system that encourages you to document your API as you go\n- Automatic api root REST endpoint generation that instantly gives you links to all top-level API endpoints\n- Automatic rel documentation site generator so that your fully resolved rel names actually, you know, point somewhere.\n- Automatic creation of curie links\n- Support for relative and templated link hrefs. \n- Auto wrapping of http response entities into HAL representations\n- Support for custom object json serialization\n- Support for programmatic configuration of HAL entities at the route or entity level\n- Bunches of unit tests\n\n##Getting Started\nStart by npm installing the halacious library into your hapi project folder:\n```\nnpm install halacious --save\n```\n\nRegister the plugin with the app server\n```javascript\nvar hapi = require('hapi');\n\nvar halaciousOpts = { \n    \n};\n\nvar server = new hapi.Server(8080);\nserver.pack.require('halacious', halaciousOpts, function(err){\n    if (err) console.log(err);\n});\n\nserver.route({\n    method: 'get',\n    path: '/hello/{name}',\n    handler: function(req, reply) {\n        reply({ message: 'Hello, '+req.params.name });\n    }\n});\n\nserver.start(function(err){\n    if (err) return console.log(err);\n    console.log('Server started at %s', server.info.uri);\n});\n```\nLaunch the server:\n```\nnode ./examples/hello-world\n```\n\nMake a request\n```\ncurl -H 'Accept: application/hal+json' http://localhost:8080/hello/world\n```\n\nSee the response\n```\n{\n    \"_links\": {\n        \"self\": {\n            \"href\": \"/hello/world\"\n        }\n    },\n    \"message\": \"Hello, world\"\n}\n```\n##Linking\nLinks may be declared directly within the route config. \n```javascript\nserver.route({\n    method: 'get',\n    path: '/users/{userId}',\n    config: {\n        handler: function (req, reply) {\n            // look up user\n            reply({ id: req.params.userId, name: 'User ' + req.params.userId, googlePlusId: '107835557095464780852' });\n        },\n        plugins: {\n            hal: {\n                links: {\n                    'home': 'http://plus.google.com/{googlePlusId}'\n                },\n                ignore: 'googlePlusId' // remove the id property from the response\n            }\n        }\n    }\n});\n```\n```\ncurl -H 'Accept: application/hal+json' http://localhost:8080/users/100\n```\nwill produce:\n```\n{\n    \"_links\": {\n        \"self\": {\n            \"href\": \"/users/1234\"\n        },\n        \"home\": {\n            \"href\": \"http://plus.google.com/107835557095464780852\"\n        }\n    },\n    \"id\": \"100\",\n    \"name\": \"User 1234\"\n}\n```\n\n##Embedding\nHAL allows you to conserve bandwidth by optionally embedding link payloads in the original request. Halacious will\nautomatically convert nested objects into embedded HAL representations (if you ask nicely).\n\n```javascript\nserver.route({\n    method: 'get',\n    path: '/users/{userId}',\n    config: {\n        handler: function (req, reply) {\n            // look up user\n            reply({\n                id: req.params.userId,\n                name: 'User ' + req.params.userId,\n                boss: {\n                    id: 1234,\n                    name: 'Boss Man'\n                }\n            });\n        },\n        plugins: {\n            hal: {\n                embedded: {\n                    'boss': {\n                        path: 'boss', // the property name of the object to embed\n                        href: '../{item.id}'\n                    }\n                }\n            }\n        }\n    }\n});\n```\n```\ncurl -H 'Accept: application/hal+json' http://localhost:8080/users/100\n\n{\n    \"_links\": {\n        \"self\": {\n            \"href\": \"/users/100\"\n        }\n    },\n    \"id\": \"100\",\n    \"name\": \"User 100\",\n    \"_embedded\": {\n        \"boss\": {\n            \"_links\": {\n                \"self\": {\n                    \"href\": \"/users/1234\"\n                }\n            },\n            \"id\": 1234,\n            \"name\": \"Boss Man\"\n        }\n    }\n}\n```\n\n## Programmatic configuration of HAL representations\nYou may find the need to take the wheel on occasion and directly configure outbound representions. For example,\nsome links may be conditional on potentially asynchronous criteria. Fortunately, Halacious provides two ways to do this:\n\n1. By providing a `prepare()` function on the route's hal descriptor (or by assigning the function directly to the hal property)\n2. By implementing a `toHal()` method directly on a wrapped entity. \n\nIn either case, the method signature is the same: `fn(rep, callback)` where\n- `rep` - a representation object with the following properties and functions:\n    - `factory` - a factory reference for creating new representations. The factory object implements one method:\n        - `create(entity, selfHref)` - wraps entity with a new Hal representation, whose self link will point to selfHref\n    - `request` - the originating hapi request\n    - `self` - a shortcut to the representation's self link\n    - `entity` - the original wrapped entity\n    - `prop(name, value)` - manually adds a name/value pair to the representation\n    - `merge(object)` - merges the properties of another object into the representation\n    - `ignore(...propertyNames)` - prevents fields from being included in the response\n    - `link(relName, href)` - adds a new link to the `_links` collection, returning the new link. Link objects support\n    the following properties (See see http://tools.ietf.org/html/draft-kelly-json-hal-06#section-8.2 for more information):\n        - `href`\n        - `templated`\n        - `title`\n        - `type`\n        - `deprecation`\n        - `name`\n        - `profile`\n        - `hreflang`\n    - `embed(rel, self, entity)` - adds an entity to the representation's `_embedded` collection with the supplied rel link relation and self href, returning a new representation\n    object for further configuration.\n- `callback([err], [representation])` - an asynchronous callback function to be called when configuration of the hal entity\nis complete. Most of the time this function should be called with no arguments. Only pass arguments if there has been\nan error or if a completely new representation has been created with `rep.factory.create()`.\n\n#### Example 1: A `prepare()` function declared in the route descriptor. \n```javascript\nserver.route({\n    method: 'get',\n    path: '/users',\n    config: {\n        handler: function (req, reply) {\n            // look up user\n            reply({\n                start: 0,\n                count: 2,\n                limit: 2,\n                items: [\n                    { id: 100, firstName: 'Brad', lastName: 'Leupen', googlePlusId: '107835557095464780852'},\n                    { id: 101, firstName: 'Mark', lastName: 'Zuckerberg'}\n                ]\n            });\n        },\n        plugins: {\n            hal: {\n                // you can also assign this function directly to the hal property above as a shortcut\n                prepare: function (rep, next) {\n                    rep.entity.items.forEach(function (item) {\n                        var embed = rep.embed('item', './' + item.id, item);\n                        if (item.googlePlusId) {\n                            embed.link('home', 'http://plus.google.com/' + item.googlePlusId);\n                            embed.ignore('googlePlusId');\n                        }\n                    });\n                    rep.ignore('items');\n                    // dont forget to call next!\n                    next();\n                }\n            }\n        }\n    }\n});\n```\n```\ncurl -H 'Accept: application/hal+json' http://localhost:8080/users\n\n{\n    \"_links\": {\n        \"self\": {\n            \"href\": \"/users\"\n        }\n    },\n    \"start\": 0,\n    \"count\": 2,\n    \"limit\": 2,\n    \"_embedded\": {\n        \"item\": [\n            {\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"/users/100\"\n                    },\n                    \"home\": {\n                        \"href\": \"http://plus.google.com/107835557095464780852\"\n                    }\n                },\n                \"id\": 100,\n                \"firstName\": \"Brad\",\n                \"lastName\": \"Leupen\"\n            },\n            {\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"/users/101\"\n                    }\n                },\n                \"id\": 101,\n                \"firstName\": \"Mark\",\n                \"lastName\": \"Zuckerberg\"\n            }\n        ]\n    }\n}\n```\n#### Example 2: Implementing `toHal()` on a domain entity:\n```javascript\nfunction User(id, firstName, lastName, googlePlusId) {\n    this.id = id;\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.googlePlusId = googlePlusId;\n}\n\nUser.prototype.toHal = function(rep, next) {\n    if (this.googlePlusId) {\n        rep.link('home', 'http://plus.google.com/' + this.googlePlusId);\n        rep.ignore('googlePlusId');\n    }\n    next();\n};\n\nserver.route({\n    method: 'get',\n    path: '/users',\n    config: {\n        handler: function (req, reply) {\n            // look up user\n            reply({\n                start: 0,\n                count: 2,\n                limit: 2,\n                items: [\n                    new User(100, 'Brad', 'Leupen', '107835557095464780852'),\n                    new User(101, 'Mark', 'Zuckerberg')\n                ]\n            });\n        },\n        plugins: {\n            hal: {\n                embedded: {\n                    item: {\n                        path: 'items',\n                        href: './{item.id}'\n                    }\n                }\n            }\n        }\n    }\n});\n```\n\n## The HAL route configuration object\nThe `config.plugins.hal` route configuration object takes the following format:\n- A function `fn(rep, next)` - for purely programmatic control over the representation\nor\n- An object with the following properties:\n    - `api` - an optional top level api rel name to assign to this route. Setting a value will cause this route to be included\n    in the root api resource's _links collection. \n    - `prepare(rep, next)` - an optional prepare function\n    - `ignore` - A String or array of strings containing the names of properties to remove from the output. Can be used\n    to remove reduntant information from the response\n    - `query` - An RFC 6570 compatible query string that should be communicated to your clients. See: http://tools.ietf.org/html/rfc6570.\n    Example: `{?q*,start,limit}`. These parameters will be included in top level api links. They will also be included in self links if supplied in the request.\n    Query parameters that are not included in the template, such as runtime tokens, will be excluded from the self href.\n    - `links` - An object whose keys are rel names and whose values are href strings or link objects that contain\n     at least an `href` property. Hrefs may be absolute or relative to the representation's self link. Hrefs may also contain\n     `{expression}` template expressions, which are resolved against the wrapped entity. \n    - `embedded` An object whose keys are rel names and whose values are configuration objects with:\n        - `path` - a path expression to evaluate against the wrapped entity to derive the object to embed. \n        - `href` - a String href or link object that will be used to define the entity's self relation. Like links,\n        embedded href's may also be templated. Unlike links, embedded href templates have access to two state variables:\n            - `self` - the parent entity \n            - `item` - the child entity\n        - `links`   \n        - `embedded` (recursively evaluated)\n        - `prepare(rep, next)`\n\n## Namespaces and Rels\nSo far, we have not done a real good job in our examples defining our link relations. Unless registered with the IANA, \nlink relations should really be unique URLs that resolve to documentation regarding their semantics. Halacious will \nhappily let you be lazy but its much better if we do things the Right Way. \n\n### Manually creating a namespace\nHalacious exposes its api to your Hapi server so that you may configure it at runtime like so:\n ```javascript\n var server = new hapi.Server(8080);\n server.pack.require('../', halaciousOpts, function(err){\n     if (err) return console.log(err);\n     var ns = server.plugins.halacious.namespaces.add({ name: 'mycompany', description: 'My Companys namespace', prefix: 'mco'});\n     ns.rel({ name: 'users', description: 'a collection of users' });\n     ns.rel({ name: 'user', description: 'a single user' });\n     ns.rel({ name: 'boss', description: 'a users boss' });\n });\n \n server.route({\n     method: 'get',\n     path: '/users/{userId}',\n     config: {\n         handler: function (req, reply) {\n             // look up user\n             reply({ id: req.params.userId, name: 'User ' + req.params.userId, bossId: 200 });\n         },\n         plugins: {\n             hal: {\n                 links: {\n                     'mco:boss': '../{bossId}'\n                 },\n                 ignore: 'bossId'\n             }\n         }\n     }\n });\n ```\n Now, when we access the server we see a new type of link in the `_links` collection, `curies`. The curies link provides a mechanism\n to use shorthand rel names while preserving their uniqueness. Without the curie, the 'mco:boss' rel key would be expanded\n to read `/rels/mycompany/boss`\n \n ```\n curl -H 'Accept: application/hal+json' http://localhost:8080/users/100\n \n {\n     \"_links\": {\n         \"self\": {\n             \"href\": \"/users/100\"\n         },\n         \"curies\": [\n             {\n                 \"name\": \"mco\",\n                 \"href\": \"/rels/mycompany/{rel}\",\n                 \"templated\": true\n             }\n         ],\n         \"mco:boss\": {\n             \"href\": \"/users/200\"\n         }\n     },\n     \"id\": \"100\",\n     \"name\": \"User 100\"\n }\n ```\n \n### Creating a namespace from a folder of documentated rels\nIn our examples folder, we have created a folder `rels/mycompany` containing markdown documents for all of the rels in our\ncompany's namespace. We can suck all these into the system in one fell swoop:\n\n```javascript\nvar server = new hapi.Server(8080);\nserver.pack.require('../', halaciousOpts, function(err){\n    if (err) return console.log(err);\n    server.plugins.halacious.namespaces.add({ dir: __dirname + '/rels/mycompany', prefix: 'mco' });\n});\n```\nIdeally these documents should provide your api consumer enough semantic information to navigate your api. \n\n## Rels documentation \nHalacious includes an (extremely) barebones namespace / rel navigator for users to browse your documentation. \nThe server binds to the `/rels` path on your server by default. \n\n## Automatic /api root\nDiscoverability is a key tenant of any hypermedia system. HAL requires that only the root API url be known to clients of your\napplication, from which all other urls may be derived via rel names. If you want, Halacious will create this root api\nroute for you automatically. All you need to do is to identify which resources to include by using the `api` route\nconfiguration option. For example:\n\n```javascript\nserver.pack.require('../', halaciousOpts, function(err){\n    if (err) return console.log(err);\n    var ns = server.plugins.halacious.namespaces.add({ name: 'mycompany', description: 'My Companys namespace', prefix: 'mco'});\n    ns.rel({ name: 'users', description: 'a collection of users' });\n    ns.rel({ name: 'user', description: 'a single user' });\n});\n\nserver.route({\n    method: 'get',\n    path: '/users',\n    config: {\n        handler: function (req, reply) {\n            // look up user\n            reply({});\n        },\n        plugins: {\n            hal: {\n                api: 'mco:users'\n            }\n        }\n    }\n});\n\nserver.route({\n    method: 'get',\n    path: '/users/{userId}',\n    config: {\n        handler: function (req, reply) {\n            // look up user\n            reply({});\n        },\n        plugins: {\n            hal: {\n                api: 'mco:user'\n            }\n        }\n    }\n});\n```\n\nwill auto-create the following api root:\n\n```\ncurl -H 'Accept: application/hal+json' http://localhost:8080/api/\n\n{\n    \"_links\": {\n        \"self\": {\n            \"href\": \"/api/\"\n        },\n        \"curies\": [\n            {\n                \"name\": \"mco\",\n                \"href\": \"/rels/mycompany/{rel}\",\n                \"templated\": true\n            }\n        ],\n        \"mco:users\": {\n            \"href\": \"/users\"\n        },\n        \"mco:user\": {\n            \"href\": \"/users/{userId}\",\n            \"templated\": true\n        }\n    }\n}\n```\n\n## Plugin Options\n- `strict` - setting this to `true` will cause an exception to be thrown when referencing unregistered local rel. Setting this\nto true will help catch typos during development. Default: `false`\n- `relsPath` - the route path to the rels documentation root. Default: `/rels`\n- `relsAuth` - the hapi authentication setting to use for the documentation routes. Default: `false`\n- `autoApi` - setting this to `true` will automatically create a root api handler to seed your client application. Default: `true`\n- `apiPath` - the route path to the api root. Default: `/api`\n- `apiAuth` - the hapi authentication setting to use for the api route. Default: `false`\n- `apiServerLabel` - when set, Halacious will select for a specific server to route the api root. \n- `mediaTypes` - an array of media types that will trigger the hal processor to modify the response (e.g. `['application/json', \n'application/hal+json']`). the media types are checked in order. if any match the accept header parameters, then the \nresponse will be halified and the media type of the response will be set to the first winner. Default: `['application/hal+json']`",
  "readmeFilename": "README.md",
  "_id": "halacious@1.2.1",
  "_shasum": "efd980bcf3982ccdf264a02e652bc5a893fbc428",
  "_from": "halacious@",
  "_resolved": "https://registry.npmjs.org/halacious/-/halacious-1.2.1.tgz"
}
