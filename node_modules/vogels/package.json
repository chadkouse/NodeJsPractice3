{
  "name": "vogels",
  "version": "0.11.0",
  "author": {
    "name": "Ryan Fitzgerald",
    "email": "ryan@codebrewstudios.com"
  },
  "description": "DynamoDB data mapper",
  "main": "index.js",
  "scripts": {
    "test": "grunt test"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/ryanfitz/vogels.git"
  },
  "keywords": [
    "datamapper",
    "DynamoDB",
    "aws",
    "amazon",
    "nosql"
  ],
  "engines": {
    "node": ">=0.10.22"
  },
  "license": "MIT",
  "dependencies": {
    "aws-sdk": "~2.0.0-rc13",
    "lodash": "2.4.x",
    "joi": "2.9.x",
    "node-uuid": "1.4.x",
    "async": "0.6.x",
    "readable-stream": "~1.0.26-2"
  },
  "devDependencies": {
    "mocha": "1.x.x",
    "chai": "1.x.x",
    "grunt-simple-mocha": "0.4.0",
    "grunt": "0.4.x",
    "grunt-contrib-jshint": "0.10.x",
    "grunt-regarde": "~0.1.1",
    "sinon": "1.9.x",
    "grunt-cli": "0.1.x"
  },
  "readme": "# vogels [![Build Status](https://travis-ci.org/ryanfitz/vogels.png?branch=master)](https://travis-ci.org/ryanfitz/vogels)\n\nvogels is a [DynamoDB][5] data mapper for [node.js][1].\n\n## Features\n* Simplified data modeling and mapping to DynamoDB types\n* Advanced chainable apis for [query](#query) and [scan](#scan) operations\n* Data validation\n* [Autogenerating UUIDs](#uuid)\n* [Global Secondary Indexes](#global-indexes)\n* [Local Secondary Indexes](#local-secondary-indexes)\n* [Parallel Scans](#parallel-scan)\n\n## Installation\n\n    npm install vogels\n\n## Getting Started\nFirst, you need to configure the [AWS SDK][2] with your credentials.\n\n```js\nvar vogels = require('vogels');\nvogels.AWS.config.loadFromPath('credentials.json');\n```\n\nYou can also directly pass in your access key id and secret\n\n```js\nvar vogels = require('vogels');\nvogels.AWS.config.update({accessKeyId: 'AKID', secretAccessKey: 'SECRET'});\n```\n\n### Define a Model\nModels are defined through the toplevel define method.\n\n```js\nvar Account = vogels.define('Account', function (schema) {\n  schema.String('email', {hashKey: true});\n  schema.String('name').required(); // name attribute is required\n  schema.Number('age'); // age is optional\n  schema.Date('created', {default: Date.now});\n});\n```\n\nModels can also be defined with hash and range keys.\n\n```js\nvar BlogPost = vogels.define('Account', function (schema) {\n  schema.String('email', {hashKey: true});\n  schema.String('title', {rangeKey: true});\n  schema.String('content');\n  schema.StringSet('tags');\n});\n```\n\n### Schema Types\nVogels provides the following schema types:\n\n* String\n* Number\n* StringSet\n* NumberSet\n* Boolean\n* Date\n* UUID\n* TimeUUID\n\n#### UUID\nUUIDs can be declared for any attributes, including hash and range keys. By\nDefault, the uuid will be automatically generated when attempting to create\nthe model in DynamoDB.\n\n```js\nvar Tweet = vogels.define('Account', function (schema) {\n  schema.UUID('TweetID', {hashKey: true});\n  schema.String('content');\n  schema.Date('created', {default: Date.now});\n});\n```\n\n### Configuration\nAfter you've defined your model you can configure the table name to use.\nBy default, the table name used will be the lowercased and pluralized version\nof the name you provided when defining the model.\n\n```js\nAccount.config({tableName: 'AccountsTable'});\n```\n\nYou can also pass in a custom instance of the aws-sdk DynamoDB client\n```js\nvar dynamodb = new AWS.DynamoDB();\nAccount.config({dynamodb: dynamodb});\n\n// or globally use custom DynamoDB instance\n// all defined models will now use this driver\nvogels.dynamoDriver(dynamodb);\n```\n\n### Saving Models to DynamoDB\nWith your models defined, we can start saving them to DynamoDB.\n\n```js\nAccount.create({email: 'foo@example.com', name: 'Foo Bar', age: 21}, function (err, acc) {\n  console.log('created account in DynamoDB', acc.get('email'));\n});\n```\n\nYou can also first instantiate a model and then save it.\n\n```js\nvar acc = new Account({email: 'test@example.com', name: 'Test Example'});\nacc.save(function (err) {\n  console.log('created account in DynamoDB', acc.get('email'));\n});\n```\n\nSaving models that require range and hashkeys are identical to ones with only\nhashkeys.\n\n```js\nBlogPost.create({\n  email: 'werner@example.com', \n  title: 'Expanding the Cloud', \n  content: 'Today, we are excited to announce the limited preview...'\n  }, function (err, post) {\n    console.log('created blog post', post.get('title'));\n  });\n```\n\n### Updating\n\nWhen updating a model the hash and range key attributes must be given, all\nother attributes are optional\n\n```js\n// update the name of the foo@example.com account\nAccount.update({email: 'foo@example.com', name: 'Bar Tester'}, function (err, acc) {\n  console.log('update account', acc.get('name'));\n});\n```\n\n`Model.update` accepts options to pass to DynamoDB when making the updateItem request\n\n```js\nAccount.update({email: 'foo@example.com', name: 'Bar Tester'}, {ReturnValues: 'ALL_OLD'}, function (err, acc) {\n  console.log('update account', acc.get('name')); // prints the old account name\n});\n\n// Only update the account if the current age of the account is 21\nAccount.update({email: 'foo@example.com', name: 'Bar Tester'}, {expected: {age: 22}}, function (err, acc) {\n  console.log('update account', acc.get('name'));\n});\n\n// setting an attribute to null will delete the attribute from DynamoDB\nAccount.update({email: 'foo@example.com', age: null}, function (err, acc) {\n  console.log('update account', acc.get('age')); // prints null\n});\n```\n\nYou can also pass what action to perform when updating a given attribute\nUse $add to increment or decrement numbers and add values to sets\n\n```js\nAccount.update({email : 'foo@example.com', age : {$add : 1}}, function (err, acc) {\n  console.log('incremented age by 1', acc.get('age'));\n});\n\nBlogPost.update({\n  email : 'werner@example.com',\n  title : 'Expanding the Cloud',\n  tags  : {$add : 'cloud'}\n}, function (err, post) {\n  console.log('added single tag to blog post', post.get('tags'));\n});\n\nBlogPost.update({\n  email : 'werner@example.com',\n  title : 'Expanding the Cloud',\n  tags  : {$add : ['cloud', 'dynamodb']}\n}, function (err, post) {\n  console.log('added tags to blog post', post.get('tags'));\n});\n```\n\n$del will remove values from a given set\n\n```js\nBlogPost.update({\n  email : 'werner@example.com',\n  title : 'Expanding the Cloud',\n  tags  : {$del : 'cloud'}\n}, function (err, post) {\n  console.log('removed cloud tag from blog post', post.get('tags'));\n});\n\nBlogPost.update({\n  email : 'werner@example.com',\n  title : 'Expanding the Cloud',\n  tags  : {$del : ['aws', 'node']}\n}, function (err, post) {\n  console.log('removed multiple tags', post.get('tags'));\n});\n```\n\n### Deleting\nYou delete items in DynamoDB using the hashkey of model\nIf your model uses both a hash and range key, than both need to be provided\n\n```js\nAccount.destroy('foo@example.com', function (err) {\n  console.log('account deleted');\n});\n\n// Destroy model using hash and range key\nBlogPost.destroy('foo@example.com', 'Hello World!', function (err) {\n  console.log('post deleted')\n});\n\nBlogPost.destroy({email: 'foo@example.com', title: 'Another Post'}, function (err) {\n  console.log('another post deleted')\n});\n```\n\n`Model.destroy` accepts options to pass to DynamoDB when making the deleteItem request\n\n```js\nAccount.destroy('foo@example.com', {ReturnValues: true}, function (err, acc) {\n  console.log('account deleted');\n  console.log('deleted account name', acc.get('name'));\n});\n\nAccount.destroy('foo@example.com', {expected: {age: 22}}, function (err) {\n  console.log('account deleted if the age was 22');\n```\n\n### Loading models from DynamoDB\nThe simpliest way to get an item from DynamoDB is by hashkey.\n\n```js\nAccount.get('test@example.com', function (err, acc) {\n  console.log('got account', acc.get('email'));\n});\n```\n\nPerform the same get request, but this time peform a consistent read.\n\n```js\nAccount.get('test@example.com', {ConsistentRead: true}, function (err, acc) {\n  console.log('got account', acc.get('email'));\n});\n```\n\n`Model.get` accepts any options that DynamoDB getItem request supports. For\nexample:\n\n```js\nAccount.get('test@example.com', {ConsistentRead: true, AttributesToGet : ['name','age']}, function (err, acc) {\n  console.log('got account', acc.get('email'))\n  console.log(acc.get('name'));\n  console.log(acc.get('age'));\n  console.log(acc.get('email')); // prints null\n});\n```\n\nGet a model using hash and range key.\n\n```js\n// load up blog post written by Werner, titled DynamoDB Keeps Getting Better and cheaper\nBlogPost.get('werner@example.com', 'dynamodb-keeps-getting-better-and-cheaper', function (err, post) {\n  console.log('loaded post by range and hash key', post.get('content'));\n});\n```\n\n`Model.get` also supports passing an object which contains hash and range key\nattributes to load up a model\n\n```js\nBlogPost.get({email: 'werner@example.com', title: 'Expanding the Cloud'}, function (err, post) {\n  console.log('loded post', post.get('content'));\n});\n```\n### Query\nFor models that use hash and range keys Vogels provides a flexible and\nchainable query api\n\n```js\n// query for blog posts by werner@example.com\nBlogPost\n  .query('werner@example.com')\n  .exec(callback);\n\n// same as above, but load all results\nBlogPost\n  .query('werner@example.com')\n  .loadAll()\n  .exec(callback);\n\n// only load the first 5 posts by werner\nBlogPost\n  .query('werner@example.com')\n  .limit(5)\n  .exec(callback);\n\n// query for posts by werner where the tile begins with 'Expanding'\nBlogPost\n  .query('werner@example.com')\n  .where('title').beginsWith('Expanding')\n  .exec(callback);\n\n// return only the count of documents that begin with the title Expanding\nBlogPost\n  .query('werner@example.com')\n  .where('title').beginsWith('Expanding')\n  .select('COUNT')\n  .exec(callback);\n\n// only return title and content attributes of 10 blog posts\n// that begin with the title Expanding\nBlogPost\n  .query('werner@example.com')\n  .where('title').beginsWith('Expanding')\n  .attriubutes(['title', 'content'])\n  .limit(10)\n  .exec(callback);\n\n// sorting by title ascending\nBlogPost\n  .query('werner@example.com')\n  .ascending()\n  .exec(callback)\n\n// sorting by title descending\nBlogPost\n  .query('werner@example.com')\n  .descending()\n  .exec(callback)\n\n// All query options are chainable\nBlogPost\n  .query('werner@example.com')\n  .where('title').gt('Expanding')\n  .attriubutes(['title', 'content'])\n  .limit(10)\n  .ascending()\n  .loadAll()\n  .exec(callback);\n```\n\nVogels supports all the possible KeyConditions that DynamoDB currently\nsupports.\n\n```js\nBlogPost\n  .query('werner@example.com')\n  .where('title').equals('Expanding')\n  .exec();\n\n// less than equals\nBlogPost\n  .query('werner@example.com')\n  .where('title').lte('Expanding')\n  .exec();\n\n// less than\nBlogPost\n  .query('werner@example.com')\n  .where('title').lt('Expanding')\n  .exec();\n\n// greater than\nBlogPost\n  .query('werner@example.com')\n  .where('title').gt('Expanding')\n  .exec();\n\n// greater than equals\nBlogPost\n  .query('werner@example.com')\n  .where('title').gte('Expanding')\n  .exec();\n\nBlogPost\n  .query('werner@example.com')\n  .where('title').beginsWith('Expanding')\n  .exec();\n\nBlogPost\n  .query('werner@example.com')\n  .where('title').between(['foo@example.com', 'test@example.com'])\n  .exec();\n```\n\n#### Global Indexes\nFirst, define a model with a global secondary index.\n\n```js\nvar GameScore = vogels.define('GameScore', function (schema) {\n  schema.String('userId', {hashKey: true});\n  schema.String('gameTitle', {rangeKey: true});\n  schema.Number('topScore');\n  schema.Date('topScoreDateTime');\n  schema.Number('wins');\n  schema.Number('losses');\n\n  schema.globalIndex('GameTitleIndex', { hashKey: 'gameTitle', rangeKey: 'topScore'});\n});\n```\n\nNow we can query against the global index \n\n```js\nGameScore\n  .query('Galaxy Invaders')\n  .usingIndex('GameTitleIndex')\n  .descending()\n  .exec(callback);\n```\n\nWhen can also configure the attributes projected into the index.\nBy default all attributes will be projected when no Projection pramater is\npresent \n\n```js\nvar GameScore = vogels.define('GameScore', function (schema) {\n  schema.String('userId', {hashKey: true});\n  schema.String('gameTitle', {rangeKey: true});\n  schema.Number('topScore');\n  schema.Date('topScoreDateTime');\n  schema.Number('wins');\n  schema.Number('losses');\n\n  schema.globalIndex('GameTitleIndex', {\n    hashKey: 'gameTitle',\n    rangeKey: 'topScore',\n    Projection: { NonKeyAttributes: [ 'wins' ], ProjectionType: 'INCLUDE' } //optional, defaults to ALL\n  });\n});\n```\n\nFilter items against the configured rangekey for the global index.\n\n```js\nGameScore\n  .query('Galaxy Invaders')\n  .usingIndex('GameTitleIndex')\n  .where('topScore').gt(1000)\n  .descending()\n  .exec(function (err, data) {\n    console.log(_.map(data.Items, JSON.stringify));\n  });\n```\n\n#### Local Secondary Indexes\nFirst, define a model using a local secondary index\n\n```js\nvar BlogPost = vogels.define('Account', function (schema) {\n  schema.String('email', {hashKey: true});\n  schema.String('title', {rangeKey: true});\n  schema.String('content');\n\n  schema.Date('PublishedDateTime', {secondaryIndex: true});\n});\n```\n\nNow we can query for blog posts using the secondary index\n\n```js\nBlogPost\n  .query('werner@example.com')\n  .usingIndex('PublishedDateTimeIndex')\n  .descending()\n  .exec(callback);\n```\n\nCould also query for published posts, but this time return oldest first\n\n```js\nBlogPost\n  .query('werner@example.com')\n  .usingIndex('PublishedDateTimeIndex')\n  .ascending()\n  .exec(callback);\n```\n\nFinally lets load all published posts sorted by publish date\n```js\nBlogPost\n  .query('werner@example.com')\n  .usingIndex('PublishedDateTimeIndex')\n  .descending()\n  .loadAll()\n  .exec(callback);\n```\n\nLearn more about [secondary indexes][3]\n\n### Scan\nVogels provides a flexible and chainable api for scanning over all your items\nThis api is very similar to the query api.\n\n```js\n// scan all accounts, returning the first page or results\nAccount.scan().exec(callback);\n\n// scan all accounts, this time loading all results\n// note this will potentially make several calls to DynamoDB \n// in order to load all results\nAccount\n  .scan()\n  .loadAll()\n  .exec(callback);\n\n// Load 20 accounts\nAccount\n  .scan()\n  .limit(20)\n  .exec();\n\n// Load All accounts, 20 at a time per request\nAccount\n  .scan()\n  .limit(20)\n  .loadAll()\n  .exec();\n\n// Load accounts which match a filter\n// only return email and created attributes\n// and return back the consumed capacity the request took\nAccount\n  .scan()\n  .where('email').gte('f@example.com')\n  .attributes(['email','created'])\n  .returnConsumedCapacity()\n  .exec();\n\n// Returns number of matching accounts, rather than the matching accounts themselves\nAccount\n  .scan()\n  .where('age').gte(21)\n  .select('COUNT')\n  .exec();\n\n// Start scan using start key\nAccount\n  .scan()\n  .where('age').notNull()\n  .startKey('foo@example.com')\n  .exec()\n```\n\nVogels supports all the possible Scan Filters that DynamoDB currently supports.\n\n```js\n// equals\nAccount\n  .scan()\n  .where('name').equals('Werner')\n  .exec();\n\n// not equals\nAccount\n  .scan()\n  .where('name').ne('Werner')\n  .exec();\n\n// less than equals\nAccount\n  .scan()\n  .where('name').lte('Werner')\n  .exec();\n\n// less than\nAccount\n  .scan()\n  .where('name').lt('Werner')\n  .exec();\n\n// greater than equals\nAccount\n  .scan()\n  .where('name').gte('Werner')\n  .exec();\n\n// greater than\nAccount\n  .scan()\n  .where('name').gt('Werner')\n  .exec();\n\n// name attribute doesn't exist\nAccount\n  .scan()\n  .where('name').null()\n  .exec();\n\n// name attribute exists\nAccount\n  .scan()\n  .where('name').notNull()\n  .exec();\n\n// contains\nAccount\n  .scan()\n  .where('name').contains('ner')\n  .exec();\n\n// not contains\nAccount\n  .scan()\n  .where('name').notContains('ner')\n  .exec();\n\n// in\nAccount\n  .scan()\n  .where('name').in(['foo@example.com', 'bar@example.com'])\n  .exec();\n\n// begins with\nAccount\n  .scan()\n  .where('name').beginsWith('Werner')\n  .exec();\n\n// between\nAccount\n  .scan()\n  .where('name').between(['Bar', 'Foo'])\n  .exec();\n\n// multiple filters\nAccount\n  .scan()\n  .where('name').equals('Werner')\n  .where('age').notNull()\n  .exec();\n```\n\n### Parallel Scan\nParallel scans increase the throughput of your table scans.\nThe parallel scan operation is identical to the scan api.\nThe only difference is you must provide the total number of segments\n\n**Caution** you can easily consume all your provisioned throughput with this api\n\n```js\nvar totalSegments = 8;\n\nAccount.parallelScan(totalSegments)\n  .where('age').gte(18)\n  .attributes('age')\n  .exec(callback);\n\n// Load All accounts\nAccount\n  .parallelScan(totalSegments)\n  .exec()\n```\n\nMore info on [Parallel Scans][4]\n\n### Batch Get Items\n`Model.getItems` allows you to load multiple models with a single request to DynamoDB.\n\nDynamoDB limits the number of items you can get to 100 or 1MB of data for a single request.\nVogels automatically handles splitting up into multiple requests to load all\nitems.\n\n```js\nAccount.getItems(['foo@example.com','bar@example.com', 'test@example.com'], function (err, accounts) {\n  console.log('loaded ' + accounts.length + ' accounts'); // prints loaded 3 accounts\n});\n\n// For models with range keys you must pass in objects of hash and range key attributes\nvar postKey1 = {email : 'test@example.com', title : 'Hello World!'};\nvar postKey2 = {email : 'test@example.com', title : 'Another Post'};\n\nBlogPost.getItems([postKey1, postKey2], function (err, posts) {\n  console.log('loaded posts');\n});\n```\n\n`Model.getItems` accepts options which will be passed to DynamoDB when making the batchGetItem request\n\n```js\n// Get both accounts, using a consistent read\nAccount.getItems(['foo@example.com','bar@example.com'], {ConsistentRead: true}, function (err, accounts) {\n  console.log('loaded ' + accounts.length + ' accounts'); // prints loaded 2 accounts\n});\n```\n\n### Streaming api\nvogels supports a basic streaming api in addition to the callback\napi for `query`, `scan`, and `parallelScan` operations.\n\n```js\nvar stream = Account.parallelScan(4).exec();\n\nstream.on('readable', function () {\n  console.log('single parallel scan response', stream.read());\n});\n\nstream.on('end', function () {\n  console.log('Parallel scan of accounts finished');\n});\n\nvar querystream = BlogPost.query('werner@vogels.com').loadAll().exec();\n\nquerystream.on('readable', function () {\n  console.log('single query response', stream.read());\n});\n\nquerystream.on('end', function () {\n  console.log('query for blog posts finished');\n});\n```\n\n### Dynamic Table Names\nvogels supports dynamic table names, useful for storing time series data.\n\n```js\nvar Event = vogels.define('Event', function (schema) {\n  schema.String('name', {hashKey: true});\n  schema.Number('total');\n\n  // store monthly event data\n  schema.tableName = function () {\n    var d = new Date();\n    return ['events', d.getFullYear(), d.getMonth() + 1].join('_');\n  };\n});\n```\n\n## Examples\n\n```js\nvar vogels = require('vogels');\n\nvar Account = vogels.define('Account', function (schema) {\n  schema.String('email', {hashKey: true});\n  schema.String('name').required();\n  schema.Number('age');\n  schema.Date('created', {default: Date.now});\n});\n\nAccount.create({email: 'test@example.com', name : 'Test Account'}, function (err, acc) {\n  console.log('created account at', acc.get('created')); // prints created Date\n\n  acc.set({age: 22});\n\n  acc.update(function (err) {\n    console.log('updated account age');\n  });\n\n});\n```\n\nSee the [examples][0] for more working sample code.\n\n## TODO\n\n* Batch Write Items\n* Streaming api support for all operations\n* DDL operations (update throughput)\n* Full intergration test suite\n\n### License\n\n(The MIT License)\n\nCopyright (c) 2014 Ryan Fitzgerald\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n[0]: https://github.com/ryanfitz/vogels/tree/master/examples\n[1]: http://nodejs.org\n[2]: http://aws.amazon.com/sdkfornodejs\n[3]: http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LSI.html\n[4]: http://aws.typepad.com/aws/2013/05/amazon-dynamodb-parallel-scans-and-other-good-news.html\n[5]: http://aws.amazon.com/dynamodb\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/ryanfitz/vogels/issues"
  },
  "homepage": "https://github.com/ryanfitz/vogels",
  "_id": "vogels@0.11.0",
  "_shasum": "a25b7f3a5e36992e98cbc1300af9f1b6191587ae",
  "_from": "vogels@",
  "_resolved": "https://registry.npmjs.org/vogels/-/vogels-0.11.0.tgz"
}
